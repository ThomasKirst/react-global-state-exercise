# Challenge: CounterApp

‚Äì> Fork / Clone this repository

- Start creating a global state in `AppLayout`.
- Your global state should have the following shape

```javascript
const [counts, setCounts] = useState({
  cats: 0,
  dogs: 0,
  sheep: 0,
  dragons: 0,
});
```

- Create a function which lets us update each item.
  This function will later be passed down to the `Counter`.

```jsx
const changeCount = (animal, count) =>
  setCounts({ ...counts, [animal]: count });
```

- Pass the function, as well as the `counts` object down to `MainContent` by using the attributes / props `counts` and `onChangeCounter`.

```jsx
<MainContent counts={counts} onChangeCount={changeCount} />
```

- Continue passing them down to the next level.

  **‚ÑπÔ∏è Do not forget to accept the props within the component on each level.**

```jsx
<CounterList counts={counts} onChangeCount={onChangeCount} />
```

- Pass it down to the level of the `Counter` component.

```jsx
<Counter name="cats" count={counts.cats} onChangeCount={onChangeCount} />
```

- You could think about iterating over the `counts` property here in order to create all counters programmatically.

```jsx
{
  Object.entries(counts).map(([animal, count]) => <li key={animal}>// ...</li>);
}
```

- ‚ö†Ô∏è Make sure to pass the `name`property as lowercase value ('cats', 'dogs', etc. instead of 'Cats', 'Dogs') since they represent the keys of our state.
  They will later be used as arguments in the `onChangeCount`function. With CSS you can adjust the output (`text-transform: capitalize`).
- Finally, we can update the state setter function within the `Counter` component. The component will receive three properties from its parent:

```jsx
export default function Counter({ name, count, onChangeCount }) {
  // ‚Ä¶
}
```

- We move from the simple setter function for the local state ‚Ä¶

```jsx
<button
  onClick={() => {
    setCount(count - 1);
  }}
>
  ‚Ä¶
</button>
```

- ‚Ä¶ to a function which updates our "global state" in the `App Layout` component.

```jsx
<button
  onClick={() => {
    onChangeCount(name, count - 1);
  }}
>
  ‚Ä¶
</button>
```

- You should now be able to safely remove the local state and the `useState` import.
- Next, we want to calculate the average of our counters, for which we write the function `averageCount` on the highest level (`AppLayout`).

```jsx
const averageCount = (counts) => {
  if (!counts) return 0;

  let allCount = 0;
  Object.entries(counts).forEach(([_, count]) => (allCount += count));

  return allCount / Object.keys(counts).length;
};
```

- üí° Pro Tip: You could calculate the average also by using the `reduce()` method, which is a bit more difficult to come up with, but this method is considered to be more elegant. But, make it work first!
- The average value of our counters needs to be passed down to the sidebar component:

```jsx
<Sidebar averageCount={averageCount(counts)} />
```

- Within our `Sidebar` component we want to display the average value as soon as it¬¥s greater than 0:

```jsx
<strong>{averageCount > 0 ? averageCount : '?'}</strong>.
```

- For the `Header` component we want to show how many "things" we are counting, e.g. we want to calculate the sum of our counters which have a value greater than 0. We write a function `thingsCounted()` ‚Äì again on the highest level.
  Do you remember the exact way in which this function works?

```jsx
const thingsCounted = Object.values(counts).filter((count) => count > 0).length;
```

- As you can see, we just derive the amount of counters, which have a value greater than 0. This will be returned as an array where we can use the `length` property in order to get the information on how many counters are actually counting.
- In the `Header` component we want to show the amount `thingsCounted`

```jsx
<Header thingsCounted={thingsCounted} />
```

- Make sure to adjust the `Header` component so it shows the value.
- Next, we want to show how many dragons were counted. We achieve this by passing down the `numberOfDragons` property to the `Footer` component.

```jsx
<Footer numberOfDragons={counts.dragons} />
```

```jsx
export default function Footer({ numberOfDragons }) {
  // ...
  return (
    <>
      Counting since {year} ‚Äî Currently there are {numberOfDragons} dragons.
    </>
  );
}
```

- There is one piece still missing. The navigation items on the bottom should be generated by our `counts` global state object. We pass the `counts` object down to the `Navigation` component.

```jsx
<Navigation counts={counts} />
```

- This is a perfect use case for mapping over the counts prop and generate our navigation items programmatically:

```jsx
<List>
    {Object.entries(counts).map(([animal, _]) => (
      // list items with links
    ))}
</List>
```

- Since the link items will be written like our object keys (cats, dogs, etc.) we can make a little CSS adjustment in our styled component `List` :

```jsx
a:any-link {
    color: #1d8382;
    text-transform: capitalize;
}
```

- How difficult is it now to add another counter, let¬¥s say for **Goldfish**?
- Bonus: Include a last counter which counts books on the sidebar using a local state variable within the `Sidebar` component.
- You made it till here ‚Äî Congratulations üéâ
- The final app could look similar to the version on the `solution` branch.
